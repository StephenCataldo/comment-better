//import CommentBetter from './CommentBetter';
import jQuery from "./maybe_bad/jquery";
window.$ = window.jQuery = jQuery;

// Track 
var idsComplete = [];


/** 
 * Create the modal 
 *
 * One day this will be React. Stuck here for now. @ToDo
 */  

  let imgClipboard = ""; 
  let modalTemplate = '<div id="cbModal">' +
	'<div class="suggestion1">How would you define... ?' + imgClipboard + '</div>' +
	'<div class="suggestion2">Good point...' + imgClipboard + '</div>' +
	'<div class="suggestion3">What made you aware of this problem?' + imgClipboard + '</div>' +
	'<div class="suggestion4">Want to talk about this in offline?' + imgClipboard + '</div>' +
  '</div>';
  let cbModal =  modalTemplate ;
  $("body").prepend(cbModal); // prepend since facebook keeps rolling?

  // Unused stuff to integrate.  
  imgClipboard = chrome.extension.getURL("img/Clipboard-Icon-20.png");
  imgClipboard = '&nbsp;<img src="' + imgClipboard + '"/>';
  $(".clipboard").css("background-image", imgClipboard);
  imgClipboard = ''; // talk to designer!! 




console.log("CommentBetterButton Initiate!!!");




/**
 * Initiate injecting Better Comment Buttons a bit after page loads.
 *
 * We want to run this after the page has loaded - don't wait for this to
 * happen if it's already done, the usual case.
 * Then stall for a moment since facebook really loads the posts with
 * javascript after the official page loadis complete 
 * Later, the mutationObserver will catch more posts. 
 ***/ 
// Reread: https://stackoverflow.com/questions/588040/window-onload-vs-document-onload. Below is a hack, sometimes document, sometimes window, expected to
// sometimes run twice (not a disaster). Document loaded should be sufficient
// for the text-oriented, DOM-oriented injectActions.
if ( document.readyState == "complete" ||
      document.readyState == "interactive" ) {
  console.log("document ready already ***");
    stallInjectButton();
  } else {
  console.log("window addEventListener for load ***");
  window.addEventListener('load', stallInjectButton());
}

/* mutationOberserver likely makes this stalling unnecessary */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
function stallInjectButton() {  
  (async () => {
    console.log('a');
    injectButton();
    await sleep(500);
    console.log('b');
    injectButton();
    await sleep(2000);
    console.log('c');
    injectButton();


  })()
}  


/**  
 * Create a MutationObserver. 
 *
 * Run it to catch nodes loaded by js after initial load.
 */ 


var observer = new MutationObserver(function(mutations) {
	mutations.forEach(function(mutation) {
    if (mutation.addedNodes &&
       (mutation.addedNodes.length > 0)) {
     
      // They never seem to come more than one at a time, right?
      // Only injectButton for UFIList (and see if that works) and carefully
      // avoid injectButton again every time we injectButton.
      // this works, until we start sending unending #cb-modal and #cbb.
      // Which @ToDo should not be IDs, should they?
      // injectButton(mutation.addedNodes[0]);

      // alternative, send just the good part: 
      // mutation.addedNodes[0].querySelectorAll(".UFIList");
      // querySelector() returns onematch or null... better?
      // if querySelectorAll, watch out for running against empty NodeList ...
      // double-warning, that's not an array (use for, not foreach:
      // https://css-tricks.com/snippets/javascript/loop-queryselectorall-matches/

      // @ToDO: more efficiently ignore non-matches.
      // NodeList [text]
      // will give errors

    
      /** Valideation efforts all failed to work. I switched to index's.
        * Figure out what went wrong below, or just stick with  
      let valid = true;
      console.log( mutation.addedNodes[0].querySelector(".UFICommentAttachmentButtons")); // the new class is there
      console.log( mutation.addedNodes[0].querySelector(".UFICommentAttachmentButtons").className); // but it's not there. fubar.
      try {
        if ( mutation.addedNodes[0].querySelector(".cbbutton") ) {
        // Note: fails if top-level, but those don't match below, so ok,
        // but perhaps inefficient. @ToDo-effiency-review, later
          console.log("WAS HERE ALREADY!!!");
          valid = false;
        } else {
          console.log("WAS NOT HERE YET");
        }
      } catch(e) {
        console.log("querySelector didn't work. This happens, not an error, leave.")
        valid = false;
        return;
      } 

      if (!valid) { return; }  
      ****/

      // Test that mutation.addedNodes[0] is a node 
      // (dups commented out stuff above)
      var UFIList;
      try {
        UFIList = mutation.addedNodes[0].querySelector(".UFIList");
      } catch(e) {
        // Not the UFIList mutation; expected.
        return;
      }

      /*** This effort fails. Note: if null, it's all skipped.
       *   UFIList children seems to have the new class, but then not.
       *   It seems like it might be some caching issue.
       **/
      // Next: if it is a node we've seen, nothing to do.
      // If not seen, 
      //   1) do the thing we do.
      //   2) give it an attribute saying we've seen it.
      if (null && UFIList != null){    // not working, give up.
        console.log(UFIList.textContent); // just text, not useful
        /* I never actually implemented this effort to see if UFIList contains
         * the new class by hand, since the normal find efforts kept failing
         * but the console shows it there.  Could try this in the future
         * (this is merely cut-and-paste text of an idea...)
        console.log("Checking for UFIList");
        console.log(UFIList); // can be null.
        console.log(typeof(UFIList));
        console.log(mutation.addedNodes[0].querySelector("a.cbbutton")); 
        console.log(mutation.addedNodes[0].querySelector("mybuttoned"));
        // I fail to understand why this is null
        console.log(UFIList.querySelector(".cbbutton")); // failing,null when should work
        console.log(UFIList.querySelectorAll(".cbbutton"));
        console.log($(UFIList).find(".mybuttoned")); // it's in there, but no. 
        // a.cbbutton is in the children of previous, why not found
        console.log($(UFIList).find("a.cbbutton"));

        // Well, shit. Maybe it's a race condition or object thing. Need
        // to modify the UFIList parent, rather than add to that object?
        console.log("Last chance:");
        console.log($(UFIList).find("UFICommentAttachmentButtons").hasClass("mybuttoned"));
        */
      }

      /** Send UFILists, whether we've processed alread or not. **/
      if (UFIList) { 
        console.log("About to do the thing");
        injectButton(UFIList);  //
      }
    
    }

	});    
});


/** 
 * Notes on MutationObserver
 *
 *  It's much cleaner if I can find the parent into which the new
 *  nodes are added ... facebook makes this hard. It's ok to not observe
 *  the initial batch when the page is ready, which seem to have a different
 *  parent - so I have it stall for about 2.5 seconds before giving up on
 *  the initial batch.
 *
 *  It seems to keep sticking things like u_fetchstream_3_0,
 *  u_fetchstream_4_1, deeper and deeper, each within each other.
 */ 
var observerConfig = {
	childList: true, // new nodes being added
  subtree: true // must be true unless figure out exactly what to observe,
                // likely just must be true.
};
 
// Try to find a narrow target, observer as little as possible.
let targetNode = document.getElementById("content_container");
// I've seen this just above the desired nodes (not sure if it is always
// there at all!). Might try, if problems:
//targetNode = document.getElementById("stream_pagelet");

targetNode = document.querySelector('div[role="feed"]');
console.log(targetNode);

// Sometimes the targetNode hasln't loaded yet, so wait and try again.
// @ToDo-loop this or something cleaner
if (targetNode) {
  observer.observe(targetNode, observerConfig);
} else {
  (async () => {
    console.log('targetNode wait and try again');
    await sleep(1700); // 2700 seems to work... 700 when connection good
    console.log('how long did that take');
    targetNode = document.querySelector('div[role="feed"]');
    console.log(targetNode);
observer.observe(targetNode, observerConfig);
  })();
}

/* Note, not used, but this is the main post class
var config = {};
config.fb_post_search = '._1dwg'; // facebook posts
*/

/**
 * main function - inject our button into the comment attachments
 *
 * .UFICommentAttachmentButtons is the box the buttons live in
 * We prepend or append a clickable image into that box
 */ 
function injectButton(domElement) {
  // defaults...
  let color =  "#fcf"; // probably color just for dev, and for Stephen
  let target = 'body';
  // ...or from mutationObserver
  if (domElement != null) {     
    target = domElement;
    color =  "#dff";
  }
 
  /** switched to indexing. This didn't fire. Seems like same issues
   * as in mutationObserver (the commented-out bits) 
  if($(target).find('.UFICommentAttachmentButtons').hasClass("mybuttoned")) { 
    console.log("***** IT ALREADY HAS THIS CLASS, ABORT *****");
  }
  **/

  // Grab the ID. (adding a class not work!)
  // ex: id="addComment_10214535777885405"
  //
  // This isn't perfect. Ultimately need one button each box for
  // the main comment box, and also replying to threads.  @ToDo
  // Clue?:  after adding this code, for the first time I see
  // "NOW IT HAS THIS CLASS, ABORT" below... before I got the exit working.
  // So somehow that was clearing a cache, or something?
  let id = $(target).find('.UFIAddComment').prop('id');
  if (idsComplete.indexOf(id) > -1) {
    console.log("This idsComplete was found already: " + id);
    return;
  } else {
    idsComplete.push(id);
  }
  console.log("New id added to list, so add the button for that id."); 
   


  $(target).find('.UFICommentAttachmentButtons').css({
    'background': color,
    }); 

  /* 
  if($(target).find('.UFICommentAttachmentButtons').hasClass("mybuttoned")) {
    console.log("***** NOW IT HAS THIS CLASS, ABORT *****");
    return;
  }
  $(target).find('.UFICommentAttachmentButtons').addClass( "mybuttoned" );  
  */

  // Note: what happens below is going to go back to the mutationObserver.
  // Have to avoid infinite loops.

  // images in chrome extensions are trick, this generates an odd URL for it
  var imgURL = chrome.extension.getURL(
    "img/commentbetter-logo-filled-right.png");
  // via facebook cut and paste
  let image = "<img class='cbb-image' src='" + imgURL +"' />";

 
  let htmlTemplate = // _r1a _5f0v     might be added back to class 
'<a onclick="openModal(e)" class="cbbutton"  aria-label="Openings: Comment Better" data-hover="tooltip" data-tooltip-alignh="center" data-tooltip-content="Comment Better" role="button" href="#">' + image + '</a>' + cbModal;

  // Overwrite cleaner, but might go back to above...
  // Note: htmlTemplate might be applied more than once at a time. No id's!
  htmlTemplate = '<a class="cbbutton">' + image + '</a>' + cbModal;


  /** @ToDos, perhaps
   * - This modal could open down if the click is high on the screen.
   * - Keep watching for what is broken by removing overflow: hidden. 
   *   But looks fine. If problems, switch to laiding the cbModal into
   *   a parent.
   * - How does the modal close? Is it comfy for most users as is?
   **/    


  
  // We're refinding, @ToDo, efficiency.
  //$(target).find('.UFICommentAttachmentButtons').prepend(htmlTemplate);
  // Future devs: sorry, I don't quite understand why jQuery can't find
  // the just-prepended links and attach events to them, and I'm exploring
  // odd ways to find the links and attach events. Chrome extensions
  // don't let functions run straightforwardly
  // Bet there are better ways to do this. @ToDo-refactor
  // (I don't want to force extra loose permissions).
  let $newbies = $(target).find('.UFICommentAttachmentButtons');
  $newbies.prepend(htmlTemplate);
  // console.log("ATTACH CLICK");    
  // Same weird issues: can't find it with jQuery find...
  // console.log($newbies.find('cbbutton')); // length 0   :-(
  // ... but it's right there:
  // console.log($newbies[0].children[0]); // this is the button

  $($newbies[0].children[0]).click(function(e){
    e.preventDefault();
    e.stopPropagation();
    let btn = this;
    let modal =  document.getElementById('cbModal');  /* or global var? */

    let scrollTop = $(window).scrollTop(); //
      // If the scrollTop + height of modal + gap > btnOffset.top, 
    let btnOffset = $(this).offset();
    let modalHeight = 230, // eyeball for now
        modalGap = 10;   // maybe tighten in final work, 
    if ( scrollTop + modalHeight + modalGap > btnOffset.top ) {
      // Under 
      let commentHeight = 32;
      $(modal).offset({ top: btnOffset.top+modalGap+commentHeight, left: btnOffset.left-100});
    } else { 
      // modal goes over, the normal expected behavior
      $(modal).offset({ top: btnOffset.top-modalHeight-modalGap, left: btnOffset.left-100}); 
    }

    // When the user clicks on the button, open the modal
    modal.style.display = "block";
    /* 
    // Where? Position the modal: 
    // element.getBoundingClientRect() are relative to the viewport.
    let btnRect = this.getBoundingClientRect();
    let modalRect = modal.getBoundingClientRect();
    */
  });

  // This can probably be removed once we only have cbModal per page
  // use parent:    _3ccb, or _5jmm      @ToDo, remove and retest
  $('.UFICommentAttachmentButtons').parents('._42ef').css("overflow", "visible");

  // @ToDo, redo modals entirely. Don't set up each separately here.

  // @ToDo ... probably should close if click btn again
  window.onclick = function(event) {
    var modal = document.getElementById('cbModal');
    var btn = document.getElementById("cbButton");


    // click outside the modal, anywhere anytime, and it's done.
    //console.log(event);
    //console.log(event.target.parentNode);
    // @ToDo: if you click on a div within modal, that's not modal
    if ((event.target != modal && event.target.parentNode != modal ) 
         && event.target != btn ) {
        modal.style.display = "none";
    }
  }
  // Get the <span> element that closes the modal -- not used, perhaps build
  //var span = document.getElementsByClassName("close")[0];
}

function openModal(e) { 
  // Stop propagation of event:
  // Do I need this? Looking at old advice on web...
  if (!e) {
    window.event.cancelBubble=true;
    // event.bubbles = false
  }
  e.stopPropagation();


  let btn = this;
      modal =  document.getElementById('cbModal');  /* or global var? */

  // When the user clicks on the button, open the modal
  modal.style.display = "block";
  /* Where? Position the modal: */
  // element.getBoundingClientRect() are relative to the viewport.
  //var bodyRect = document.body.getBoundingClientRect(),
  let btnRect = btn.getBoundingClientRect(),
      modalRect = modal.btn.getBoundingClientRect();
//  = elemRect.top - bodyRect.top;
  console.log("Where are my toys?");
  console.log(btnRect);
  console.log(modalRect);
}
