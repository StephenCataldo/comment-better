diff --git a/chrome/extension/inject.js b/chrome/extension/inject.js
index 17ae786..89f10cc 100644
--- a/chrome/extension/inject.js
+++ b/chrome/extension/inject.js
@@ -1,12 +1,13 @@
 //import CommentBetter from './CommentBetter';
 import jQuery from "./maybe_bad/jquery";
 window.$ = window.jQuery = jQuery;
-var idsComplete = [];
-
 
 
-/** create the modal **/
-// Where should this really go? Should this be background?
+/** 
+ * Create the modal 
+ *
+ * One day this will be React. Stuck here for now. @ToDo
+ */  
 
   let imgClipboard = ""; 
   let modalTemplate = '<div id="cbModal">' +
@@ -18,77 +19,81 @@ var idsComplete = [];
   let cbModal =  modalTemplate ;
   $("body").prepend(cbModal); // prepend since facebook keeps rolling?
 
+  // Unused stuff to integrate.  
+  imgClipboard = chrome.extension.getURL("img/Clipboard-Icon-20.png");
+  imgClipboard = '&nbsp;<img src="' + imgClipboard + '"/>';
+  $(".clipboard").css("background-image", imgClipboard);
+  imgClipboard = ''; // talk to designer!! 
+
 
 
 
 console.log("CommentBetterButton Initiate!!!");
 
-function cbModal(id) { console.log("open " + id); }
 
-// TEMP!!
-function sleep(ms) {
-  return new Promise(resolve => setTimeout(resolve, ms));
-}
 
-// For simple page: document readyState is complete
-// The window tends to take a while to load. I think something done
-// faster might be ok?
+
+/**
+ * Initiate injecting Better Comment Buttons a bit after page loads.
+ *
+ * We want to run this after the page has loaded - don't wait for this to
+ * happen if it's already done, the usual case.
+ * Then stall for a moment since facebook really loads the posts with
+ * javascript after the official page loadis complete 
+ * Later, the mutationObserver will catch more posts. 
+ ***/ 
 // Reread: https://stackoverflow.com/questions/588040/window-onload-vs-document-onload. Below is a hack, sometimes document, sometimes window, expected to
 // sometimes run twice (not a disaster). Document loaded should be sufficient
 // for the text-oriented, DOM-oriented injectActions.
-console.log(window.window_name);
-var windw = window.window_name;
 if ( document.readyState == "complete" ||
       document.readyState == "interactive" ) {
   console.log("document ready already ***");
-//injectActions();
-
-  // facebook loads after document officially says it 's ready, so slow down.
-  
-(async () => {
-  console.log('a');
-  await sleep(2700);
-  console.log('b');
-  doTheThing();
-  console.log('c');
-})()
-  
-
+    stallInjectButton();
   } else {
   console.log("window addEventListener for load ***");
-  window.addEventListener('load', doTheThing());
+  window.addEventListener('load', stallInjectButton());
 }
 
+/* mutationOberserver likely makes this stalling unnecessary */
+function sleep(ms) {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+function stallInjectButton() {  
+  (async () => {
+    console.log('a');
+    injectButton();
+    await sleep(500);
+    console.log('b');
+    injectButton();
+    await sleep(2000);
+    console.log('c');
+    injectButton();
 
-//  Create a MutationObserver. Run it after running the above?
-// started in:  CommentBetter.js
-// This code from tutorials.
 
-var observer = new MutationObserver(function(mutations) {
-	// For the sake of...observation...let's output the mutation to console to see how this all works
-	// seeking 0:div.UFIList    
+  })()
+}  
 
-/*	console.log('+++++++++++++++'); */
+
+/**  
+ * Create a MutationObserver. 
+ *
+ * Run it to catch nodes loaded by js after initial load.
+ */ 
+
+// Track 
+var idsComplete = [];
+
+var observer = new MutationObserver(function(mutations) {
 	mutations.forEach(function(mutation) {
     if (mutation.addedNodes &&
        (mutation.addedNodes.length > 0)) {
-
-/*
-      console.log('-----Mutation-----');
-      //childlist is the only we bother with: console.log(mutation.type);
-      //console.log(mutation);
-      console.log(mutation.addedNodes);
-*/
-        
-      //This is the html, a piece of the DOM, that contains what we want.
-      // Is this a DOM element? Can I run functions off it?
-      //console.log(mutation.addedNodes[0]);
+     
       // They never seem to come more than one at a time, right?
-      // Only doTheThing for UFIList (and see if that works) and carefully
-      // avoid doTheThing again every time we doTheThing.
-      //this works, until we start sending unending #cb-modal and #cbb.
-      //Which @ToDo should not be IDs, should they?
-      //doTheThing(mutation.addedNodes[0]);
+      // Only injectButton for UFIList (and see if that works) and carefully
+      // avoid injectButton again every time we injectButton.
+      // this works, until we start sending unending #cb-modal and #cbb.
+      // Which @ToDo should not be IDs, should they?
+      // injectButton(mutation.addedNodes[0]);
 
       // alternative, send just the good part: 
       // mutation.addedNodes[0].querySelectorAll(".UFIList");
@@ -97,17 +102,13 @@ var observer = new MutationObserver(function(mutations) {
       // double-warning, that's not an array (use for, not foreach:
       // https://css-tricks.com/snippets/javascript/loop-queryselectorall-matches/
 
-      // @ToDO:
+      // @ToDO: more efficiently ignore non-matches.
       // NodeList [text]
       // will give errors
 
-      // If we've been here already, run away. I'm seeing 3-5 runs per node.
-      // @ToDo: figure out why it runs more than once.
-      // @ToDo: I think this helps, and should stay here, perhaps ... now I see
-      // 1-3 buttons per node, not up to 5. Could be shifting internet speed though.
-      //
-      //
-      /* Valideation efforts all failed to work.
+    
+      /** Valideation efforts all failed to work. I switched to index's.
+        * Figure out what went wrong below, or just stick with  
       let valid = true;
       console.log( mutation.addedNodes[0].querySelector(".UFICommentAttachmentButtons")); // the new class is there
       console.log( mutation.addedNodes[0].querySelector(".UFICommentAttachmentButtons").className); // but it's not there. fubar.
@@ -139,28 +140,20 @@ var observer = new MutationObserver(function(mutations) {
         return;
       }
 
-
-      // Something not writ with testing UFIList. I give up here.
-      // Is it some kind of caching issue?
+      /*** This effort fails. Note: if null, it's all skipped.
+       *   UFIList children seems to have the new class, but then not.
+       *   It seems like it might be some caching issue.
+       **/
+      // Next: if it is a node we've seen, nothing to do.
+      // If not seen, 
+      //   1) do the thing we do.
+      //   2) give it an attribute saying we've seen it.
       if (null && UFIList != null){    // not working, give up.
         console.log(UFIList.textContent); // just text, not useful
         /* I never actually implemented this effort to see if UFIList contains
          * the new class by hand, since the normal find efforts kept failing
          * but the console shows it there.  Could try this in the future
          * (this is merely cut-and-paste text of an idea...)
-        function DOMComb (oParent, oCallback) {
-          if (oParent.hasChildNodes()) {
-            for (var oNode = oParent.firstChild; oNode; oNode = oNode.nextSibling) {
-              DOMComb(oNode, oCallback);
-            }
-          }
-          oCallback.call(oParent);
-        }
-
-          DOMComb(UFIList, console.log());
-        */
-
-
         console.log("Checking for UFIList");
         console.log(UFIList); // can be null.
         console.log(typeof(UFIList));
@@ -169,72 +162,58 @@ var observer = new MutationObserver(function(mutations) {
         // I fail to understand why this is null
         console.log(UFIList.querySelector(".cbbutton")); // failing,null when should work
         console.log(UFIList.querySelectorAll(".cbbutton"));
-        
-        console.log($(UFIList).find(".mybuttoned")); // it's in there, but no. stumped
-            // a.cbbutton is in the children of previous, why not found
+        console.log($(UFIList).find(".mybuttoned")); // it's in there, but no. 
+        // a.cbbutton is in the children of previous, why not found
         console.log($(UFIList).find("a.cbbutton"));
 
         // Well, shit. Maybe it's a race condition or object thing. Need
         // to modify the UFIList parent, rather than add to that object?
-        //
-        //
         console.log("Last chance:");
         console.log($(UFIList).find("UFICommentAttachmentButtons").hasClass("mybuttoned"));
+        */
       }
 
+      /** Send UFILists, whether we've processed alread or not. **/
       if (UFIList) { 
         console.log("About to do the thing");
-        doTheThing(UFIList);  //
+        injectButton(UFIList);  //
       }
     
     }
-      // =  attributes, childList over and over
-
-    // Next: if it is a node we've seen, nothing to do.
-    // If not seen, 
-    //   1) do the thing we do.
-    //   2) give it an attribute saying we've seen it.
 
 	});    
 });
 
 
-/*** Notes on MutationObserver
+/** 
+ * Notes on MutationObserver
+ *
  *  It's much cleaner if I can find the parent into which the new
  *  nodes are added ... facebook makes this hard. It's ok to not observe
  *  the initial batch when the page is ready, which seem to have a different
- *  parent. It seems to keep sticking things like u_fetchstream_3_0,
- *  u_fetchstream_4_1, deeper and deeper, each within each other.
+ *  parent - so I have it stall for about 2.5 seconds before giving up on
+ *  the initial batch.
  *
- *  A post=node has classes like this: _5jmm _5pat _3lb4 k_t-2r1p193
- * 
- *
- **/ 
-// Notify me of everything!
+ *  It seems to keep sticking things like u_fetchstream_3_0,
+ *  u_fetchstream_4_1, deeper and deeper, each within each other.
+ */ 
 var observerConfig = {
-	//attributes: true, 
-	childList: true, // it was a mutation to the tree of nodes.
-	//characterData: true,
-  subtree: true // can't tell, suspect must be true
+	childList: true, // new nodes being added
+  subtree: true // must be true unless figure out exactly what to observe,
+                // likely just must be true.
 };
  
-// Node, config
-// In this case we'll listen to all changes to body and child nodes
-var targetNode = document.body; // @ToDo: narrow this down? No sidebar.
-//targetNode = document.querySelectorAll('[role=feed]')[0];
-targetNode = document.getElementById("content_container");
-  // works with subtree true, not otherwise
-
+// Try to find a narrow target, observer as little as possible.
+let targetNode = document.getElementById("content_container");
 // I've seen this just above the desired nodes (not sure if it is always
-// there at all!)
-// I don't even see this ... every time I look at fb it changes.
+// there at all!). Might try, if problems:
+//targetNode = document.getElementById("stream_pagelet");
+
 targetNode = document.querySelector('div[role="feed"]');
-// Sometimes this works, but not sure about always or when.
-// not seen work with subtree false
-// And now it doesn't work?
-// This looks closest. It's not always ready. This could be solved
-// by waiting until it is found.
 console.log(targetNode);
+
+// Sometimes the targetNode hasln't loaded yet, so wait and try again.
+// @ToDo-loop this or something cleaner
 if (targetNode) {
   observer.observe(targetNode, observerConfig);
 } else {
@@ -247,110 +226,82 @@ if (targetNode) {
 observer.observe(targetNode, observerConfig);
   })();
 }
-//targetNode = document.getElementById("stream_pagelet");
-// workes with subtree true...
-
-
-//#stream_pagelet ... sometimes I see this.
-// aria-label="News Feed"
-
-
-
- //   var containerNode = document.getElementById("globalContainer");
- //   var bodyNode = document.getElementsByTagName("body");
-//Nothing: observer.observe(containerNode, observerConfig);
-//observer.observe(bodyNode, observerConfig);
-
-
-
 
+/* Note, not used, but this is the main post class
 var config = {};
 config.fb_post_search = '._1dwg'; // facebook posts
-var fb_post_count = 0;
-
-/*
-function dotheOtherThing(innerHTML) {
-  innerHTML
 */
 
-function doTheThing(domElement) {
-  //domElement is what $(xx).get() would get.
-  let color =  "#fcf";
+/**
+ * main function - inject our button into the comment attachments
+ *
+ * .UFICommentAttachmentButtons is the box the buttons live in
+ * We prepend or append a clickable image into that box
+ */ 
+function injectButton(domElement) {
+  // defaults...
+  let color =  "#fcf"; // probably color just for dev, and for Stephen
   let target = 'body';
-  if (domElement != null) {
+  // ...or from mutationObserver
+  if (domElement != null) {     
     target = domElement;
     color =  "#dff";
-    console.log("found a feed thing");
-      
-  } else {
-    console.log("starting things found");
   }
-  
-// .UFICommentAttachmentButtons is the box the buttons live in
-// We prepend or append a clickable image into that box
-
-console.log($(target).find('.UFICommentAttachmentButtons').html());
- if($(target).find('.UFICommentAttachmentButtons').hasClass("mybuttoned")) { 
-   console.log("***** IT ALREADY HAS THIS CLASS, ABORT *****");
- }
-
+ 
+  /** switched to indexing. This didn't fire. Seems like same issues
+   * as in mutationObserver (the commented-out bits) 
+  if($(target).find('.UFICommentAttachmentButtons').hasClass("mybuttoned")) { 
+    console.log("***** IT ALREADY HAS THIS CLASS, ABORT *****");
+  }
+  **/
 
   // Grab the ID. (adding a class not work!)
   // ex: id="addComment_10214535777885405"
   //
   // This isn't perfect. Ultimately need one button each box for
-  // the main comment box, and also replying to threads. 
-  // Also, after adding this code, for the first time I see
-  // "NOW IT HAS THIS CLASS, ABORT" below. 
+  // the main comment box, and also replying to threads.  @ToDo
+  // Clue?:  after adding this code, for the first time I see
+  // "NOW IT HAS THIS CLASS, ABORT" below... before I got the exit working.
+  // So somehow that was clearing a cache, or something?
   let id = $(target).find('.UFIAddComment').prop('id');
-  console.log("Now test ids:");
-  console.log(id);
   if (idsComplete.indexOf(id) > -1) {
     console.log("This idsComplete was found already: " + id);
     return;
   } else {
     idsComplete.push(id);
-    console.log("idsComplete now...");
-    console.log(idsComplete);
   }
   console.log("New id added to list, so add the button for that id."); 
    
 
 
- $(target).find('.UFICommentAttachmentButtons').css({
+  $(target).find('.UFICommentAttachmentButtons').css({
     'background': color,
     }); 
- 
- if($(target).find('.UFICommentAttachmentButtons').hasClass("mybuttoned")) {
-   console.log("***** NOW IT HAS THIS CLASS, ABORT *****");
-   return;
- }
-
-
- $(target).find('.UFICommentAttachmentButtons').addClass( "mybuttoned" );  
 
-// SHIT. Shut the observer from what we do below.
+  /* 
+  if($(target).find('.UFICommentAttachmentButtons').hasClass("mybuttoned")) {
+    console.log("***** NOW IT HAS THIS CLASS, ABORT *****");
+    return;
+  }
+  $(target).find('.UFICommentAttachmentButtons').addClass( "mybuttoned" );  
+  */
 
+  // Note: what happens below is going to go back to the mutationObserver.
+  // Have to avoid infinite loops.
 
   // images in chrome extensions are trick, this generates an odd URL for it
-  var imgURL = chrome.extension.getURL("img/commentbetter-logo-filled-right.png");
-  var imgClipboard = chrome.extension.getURL("img/Clipboard-Icon-20.png");
-  imgClipboard = '&nbsp;<img src="' + imgClipboard + '"/>';
-
-
+  var imgURL = chrome.extension.getURL(
+    "img/commentbetter-logo-filled-right.png");
   // via facebook cut and paste
   let image = "<img class='cbb-image' src='" + imgURL +"' />";
-  $(".clipboard").css("background-image", imgClipboard);
-  imgClipboard = ''; // talk to designer!! 
+
  
-    let htmlTemplate = // _r1a _5f0v     might be added back to class 
+  let htmlTemplate = // _r1a _5f0v     might be added back to class 
 '<a onclick="openModal(e)" class="cbbutton"  aria-label="Openings: Comment Better" data-hover="tooltip" data-tooltip-alignh="center" data-tooltip-content="Comment Better" role="button" href="#">' + image + '</a>' + cbModal;
-// Overwrite cleaner, but might go back to above...
-htmlTemplate = '<a id="cbb' +  + '" onclick="openModal(e)" class="cbbutton">' + image + '</a>' + cbModal;
-htmlTemplate = '<a class="cbbutton">' + image + '</a>' + cbModal;
 
-
-// Note: htmlTemplate might be applied more than once at a time. No id's!
+  // Overwrite cleaner, but might go back to above...
+  // Note: htmlTemplate might be applied more than once at a time. No id's!
+  htmlTemplate = '<a class="cbbutton">' + image + '</a>' + cbModal;
 
 
   /** @ToDos, perhaps
@@ -373,25 +324,15 @@ htmlTemplate = '<a class="cbbutton">' + image + '</a>' + cbModal;
   // (I don't want to force extra loose permissions).
   let $newbies = $(target).find('.UFICommentAttachmentButtons');
   $newbies.prepend(htmlTemplate);
-console.log("ATTACH CLICK");    
-console.log($newbies);
-console.log($newbies.find('cbbutton')); // length 0   :-(
-// Gives uncaught errors when undefined. Dig to make sure can simply be ignored:
-console.log($newbies[0].children[0]); // this is the button
+  // console.log("ATTACH CLICK");    
+  // Same weird issues: can't find it with jQuery find...
+  // console.log($newbies.find('cbbutton')); // length 0   :-(
+  // ... but it's right there:
+  // console.log($newbies[0].children[0]); // this is the button
 
   $($newbies[0].children[0]).click(function(e){
-  //$newbies.find('cbbutton').click(function(e){
-   
-
-    //$(this.href).show();
     e.preventDefault();
     e.stopPropagation();
-console.log(e);
-console.log(this); // the button! yes!
-
-    /** Positioning
-     * .position() is relative to parent, .offset() to document. 
-     **/ 
     let btn = this;
     let modal =  document.getElementById('cbModal');  /* or global var? */
 
@@ -404,58 +345,43 @@ console.log(this); // the button! yes!
       // Under 
       let commentHeight = 32;
       $(modal).offset({ top: btnOffset.top+modalGap+commentHeight, left: btnOffset.left-100});
-    } else { // modal goes over, the normal expected behavior
+    } else { 
+      // modal goes over, the normal expected behavior
       $(modal).offset({ top: btnOffset.top-modalHeight-modalGap, left: btnOffset.left-100}); 
     }
 
-    console.log(modal); // yes, this is the modal.
     // When the user clicks on the button, open the modal
     modal.style.display = "block";
-    /* Where? Position the modal: */
+    /* 
+    // Where? Position the modal: 
     // element.getBoundingClientRect() are relative to the viewport.
-    //var bodyRect = document.body.getBoundingClientRect(),
     let btnRect = this.getBoundingClientRect();
     let modalRect = modal.getBoundingClientRect();
-  //  = elemRect.top - bodyRect.top;
-    console.log("Where are my toys?");
-    console.log(btnRect);
-    console.log(modalRect);
-
-
+    */
   });
 
   // This can probably be removed once we only have cbModal per page
-  // use parent:    _3ccb, or _5jmm
+  // use parent:    _3ccb, or _5jmm      @ToDo, remove and retest
   $('.UFICommentAttachmentButtons').parents('._42ef').css("overflow", "visible");
-  // This is untested, might possibly work for all we know, in case that above
-  // overflow actually matters for something.
-  //$('.UFICommentAttachmentButtons').parents('_3ccb').append(cbModal);
-
-  /* Make the modal show up or close **/
-  var modal = document.getElementById('cbModal');
-
-  // Get the button that opens the modal
-  var btn = document.getElementById("cbButton");
 
   // @ToDo, redo modals entirely. Don't set up each separately here.
 
   // @ToDo ... probably should close if click btn again
-  // window is apparently null?
-  console.log(window);
-  if ( window == null ) { console.log("Hey, why is window null?????? ID: " + id); }
   window.onclick = function(event) {
+    var modal = document.getElementById('cbModal');
+    var btn = document.getElementById("cbButton");
+
+
     // click outside the modal, anywhere anytime, and it's done.
-    console.log("event target is a problem: ");
-    console.log(event);
-    console.log(event.target.parentNode);
-    // event.currentTarget
+    //console.log(event);
+    //console.log(event.target.parentNode);
     // @ToDo: if you click on a div within modal, that's not modal
     if ((event.target != modal && event.target.parentNode != modal ) 
          && event.target != btn ) {
         modal.style.display = "none";
     }
   }
-  // Get the <span> element that closes the modal
+  // Get the <span> element that closes the modal -- not used, perhaps build
   //var span = document.getElementsByClassName("close")[0];
 }
 
